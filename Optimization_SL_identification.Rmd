### Pipeline 
**Remember:** issue when using tab deliminated file obtained with vcftools after calling genotypes from all the sites: takes a very long time. We need to have this "big file" to have sites only present in one of the 2 sexes since we are using our chimerical genome (which are supposed to have all the possible sites - so can't obtain sites with insertion compared to the reference genome). Sites that are homozygous in one sex and missing in the other won't be called as SNP, consider as an active region by GATK (since no difference in theory with the reference for some individuals and missing data for other individuals).
When we call variants with Haplotype caller, we only obtain only 1 sex if it differs from the reference (ex. A in reference, T in one sex or A/T) but we expect no difference for one sex compare to the reference (ex. A in reference, A/A in one sex, ./. in the other). So we need to call all the confident sites.

1- perl script `script_find_sex_linked_regions` to find the sites that are "Sex linked" & polymorphic 

*Inputs:* tab deliminated file from GATK/vcftools

*Outputs:* tab deliminated files: 

          a) Polymorphic file: dad/mom/son/daughter_heterozygous \t supercontig_name \t position  
          
          b) Sex linked file: XY/ZW_system(also can contain in addition "Only_son" or "Only_daughter") \t supercontig_name \t position

2- C++ script `add the final name of the script there` to obtain the positions of the different types of genotypes on the real scaffold (count the number of genotypes from each categories on each real scaffold) 

*Inputs:* Index (supercontig_number \t real_scaffold_name \t start \t end), Polymorphic, Sex linked & the tab deliminated from GATK/vcftools (for counting the total number of genotypes called / real scaffold) files

*Outputs:* tab deliminated files:

          a) `count.txt` (11 columns): scaffold_name \t number_total_called_genotype \t number_XY_sites \t number_ZW_sites \t number_polymorphic_dad_sites \t number_polymorphic_mom_sites \t number_polymorphic_daughter_sites \t number_polymorphic_son_sites \t scaffold_size
          
          b) `count_scaffolds_per_SD_system.txt`: "XY_scaffolds_number" \t count \t "ZW_scaffolds_number" \t count
          
3- perl little script `add the final name of the script there` to obtain the scaffolds displaying a sex inheritance pattern

*Inputs:* `count.txt`, `SOAP_Hymeno_genome.scafSeq`

*Outputs:* file with scaffolds that display sex-inheritance pattern. In the sequence name: `>scaffold_name \t XY(or ZW)`

###Scripts
NOTE:need to check and run it after the simplification compared to the previous script which was doing all the steps with perl.
`1st_part.pl`
```perl
#!/usr/local/perl5.24/perl-5.24.0/perl

use strict;
use warnings;
use List::MoreUtils qw/ uniq /;
use List::Util qw(min max);

# This script reads in a tab delimited files that has scaffold
# positions in a concatenated reference genome.  It generates
# 2 files: 1 containing the information of the potential 
# sex-linked sites & 1 containing the information of polymorphic sites.
# Both files will be used later as inputs of main.cpp

##Define all the different input and output files

######OUTPUT file

my $path_to_output="/net/infofile4-inside/volume1/scratch/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/UnifiedGenotyper/noMarkDupli/multiple_steps/";

my $outputfile1 = $path_to_output."Hymenochirus_sex_linked_sites_Phred20_UnifiedGenotyper_1st_part.txt";
unless (open(OUTFILE1, ">$outputfile1")){
    print "I can\'t write to $outputfile1   $!\n\n";
    exit;
}

my $outputfile2 = $path_to_output."Hymenochirus_invalid_sites_Phred20_UnifiedGenotyper_1st_part.txt";
unless(open(OUTFILE2, ">$outputfile2")){
   print "I can\'t write to $outputfile2   $!\n\n";
    exit;
}

my $outputfile3 = $path_to_output."Hymenochirus_polymorphic_sites_Phred20_UnifiedGenotyper_1st_part.txt";
unless(open(OUTFILE3, ">$outputfile3")){
    print "I can\'t write to $outputfile3   $!\n\n";
    exit;
}

#my $path_to_output="/net/infofile4-inside/volume1/scratch/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/UnifiedGenotyper/noMarkDupli/big_scaffolds_separated/";
#my $separated_scaffold="supercontig_1";

#my $outputfile1 = $path_to_output.$separated_scaffold."\/Hymenochirus_sex_linked_sites_Phred20_UnifiedGenotyper_v6_opt.txt";
#unless (open(OUTFILE1, ">$outputfile1")){
#    print "I can\'t write to $outputfile1   $!\n\n";
#    exit;
#}

#my $outputfile2 = $path_to_output.$separated_scaffold."\/Hymenochirus_invalid_sites_Phred20_UnifiedGenotyper_v6_opt.txt";
#unless(open(OUTFILE2, ">$outputfile2")){
#   print "I can\'t write to $outputfile2   $!\n\n";
#    exit;
#}

#my $outputfile3 = $path_to_output.$separated_scaffold."\/Hymenochirus_polymorphic_sites_Phred20_UnifiedGenotyper_v6_opt.txt";
#unless(open(OUTFILE2, ">$outputfile2")){
#    print "I can\'t write to $outputfile2   $!\n\n";
#    exit;
#}


######INPUT file 

my $inputfile1 ="/net/infofile4-inside/volume1/scratch/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/UnifiedGenotyper/noMarkDupli/SOAP_Chimerical_recalibrated_round1_allsites_Phred20.tab";

#my $inputfile1 = $path_to_output.$separated_scaffold."\/SOAP_Chimerical_recalibrated_round1_allsites_Phred20_".$separated_scaffold.".tab";

unless (open DATAINPUT1, $inputfile1) {
        print "Can not find the input file $inputfile1, jackass.\n";
        exit;
}

my $inputfile2 = "/net/infofile4-inside/volume1/scratch/evanslab/Hymenochirus_2016/GBS_data/pedigree_copy";

unless (open DATAINPUT2, $inputfile2) {
        print "Can not find the input file $inputfile2, jackass.\n";
        exit;
}

#my $inputfile1 = $path_to_output.$separated_scaffold."\/SOAP_Chimerical_recalibrated_round1_allsites_Phred20_".$separated_scaffold.".tab";

#unless (open DATAINPUT1, $inputfile1) {
#        print "Can not find the input file $inputfile1, jackass.\n";
#        exit;
#}

#my $inputfile2 = "/net/infofile4-inside/volume1/scratch/evanslab/Hymenochirus_2016/GBS_data/pedigree_copy";

#unless (open DATAINPUT2, $inputfile2) {
#        print "Can not find the input file $inputfile2, jackass.\n";
#        exit;
#}

#my $ex = sprintf "%.0f", (5/2);
#print $ex; 

###TEST
#my $outputfile1 = "Hymenochirus_sex_linked_sites_opt_1stpart.txt";
#unless (open(OUTFILE1, ">$outputfile1")){
#   print "I can\'t write to $outputfile1   $!\n\n";
#   exit;
#}

#my $outputfile2 = "Hymenochirus_invalid_sites_opt_1stpart.txt";
#unless(open(OUTFILE2, ">$outputfile2")){
#   print "I can\'t write to $outputfile2   $!\n\n";
#   exit;
#}

#my $outputfile3 = "Hymenochirus_polymorphic_sites_opt_1stpart.txt";
#unless(open(OUTFILE3, ">$outputfile3")){
#   print "I can\'t write to $outputfile3   $!\n\n";
#   exit;
#}

#my $inputfile1 = "sample_SOAP_allconf_test.tab";

#unless (open DATAINPUT1, $inputfile1) {
#        print "Can not find the input file $inputfile1, jackass.\n";
#        exit;
#}

#my $inputfile2 = "pedigree_copy";

#unless (open DATAINPUT2, $inputfile2) {
#        print "Can not find the input file $inputfile2, jackass.\n";
#        exit;
#}

##Load inputfile1 info in hashes
#It is the file which make the ling between supercontigs coordinates and real contigs produced by an assembler

my @temp;
my $line;


##Pedigree file: contains individual ID and family state (mom, dad, daughter, son) 
my %sampleID;
my @columnF2;
while (my $line2 = <DATAINPUT2>){
        chomp($line2);
        @columnF2=split('\t',$line2);
        $sampleID{$columnF2[0]}=$columnF2[1];
}


my $supercontigs;
my $genotype_position;
my @columnF1;
my @boys;
my @girls;
my $mom;
my $dad;
my $minimum_number_of_genotypes_from_sons;
my $minimum_proportion_of_genotypes_from_one_offspring_sex=0.8;
my $minimum_number_of_genotypes_from_daughters; 
my @bases;
my @daughter_genotypes;
my @son_genotypes;
my @unique_daughters;
my %unique_daug_geno;
my %unique_son_geno;
my @unique_sons;
my @homozygous_genotypes=("A\/A","C\/C","T\/T","G\/G");
my @heterozygous_genotypes=("A\/C","C\/A","A\/G","G\/A","A\/T","T\/A","G\/C","C\/G","C\/T","T\/C","G\/T","T\/G");
my $genotype_position_real_contigs;
my @supercontigs_sex_spec;
my @genotype_position_superconig_sex_spec;
my %all_genotype;
my %real_contigs;
my $first_genotype_daughters;
my $first_genotype_sons;
my $i=0;
my @temp4;
my @geno_mom_dad;
my $temp;
my @tempB;
my $geno_mom_dad;
my $y;
my %polymorphic_sites_mom;
my %polymorphic_sites_dad;
my %polymorphic_sites_daughter_only;
my %polymorphic_sites_son_only;


##VCF_tab contains information about genotypes of the family (SNPs are called using superscaffolds assembly)
#we are looking for sites that differ between males and females
#i.e.: sites homoz in dad (+sons) heteroz in mom (+daughters)
#we need to take into account sequencing errors and under-calling sites

while (my $line1=<DATAINPUT1>) {
        chomp($line1);
    @columnF1=split('\t',$line1);
    if($columnF1[0] eq '#CHROM'){
        print OUTFILE1 $line1,"\n";
        print OUTFILE2 $line1,"\n";
                    print OUTFILE3 $line1,"\n";
        $minimum_number_of_genotypes_from_sons=$minimum_proportion_of_genotypes_from_one_offspring_sex*($#boys+1);
        $minimum_number_of_genotypes_from_daughters=$minimum_proportion_of_genotypes_from_one_offspring_sex*($#girls+1);
       for ($y = 0 ; $y <= $#columnF1 ; $y++ ) {
            foreach my $key (keys %sampleID) {
                if($columnF1[$y] =~ $key){
                    if($sampleID{$key} eq 'mom'){
                        $mom=$y;
                        print "it is mom ",$y,"\n";
                    }
                    elsif($sampleID{$key} eq 'dad'){
                        $dad=$y;
                        print "it is dad ",$y,"\n"
                    }
                    elsif($sampleID{$key} eq 'son'){
                        push(@boys,$y);
                        print "it is a son ",$y,"\n";
                    }
                    elsif($sampleID{$key} eq 'daughter'){
                        push(@girls,$y);
                        print "it is a daughter ",$y,"\n";
                    }
                    else{
                        print "Something is wrong with this ID ",$y,"\n";
                    }
                }
            }
        }
    $minimum_number_of_genotypes_from_sons=$minimum_proportion_of_genotypes_from_one_offspring_sex*($#boys+1);
    $minimum_number_of_genotypes_from_daughters=$minimum_proportion_of_genotypes_from_one_offspring_sex*($#girls+1);
    print "minimum_number_of_genotypes_from_sons ",$minimum_number_of_genotypes_from_sons," number boys ", $#boys+1, "\n";  
    }
    else{
        # get rid of the first part of the supercontig name
        @temp=split('_',$columnF1[0]);
        $columnF1[0]=$temp[1];

        # Make AC CA (...) genotypes equivalent (needed for "uniq" function)
        for ($y=0 ; $y<=$#columnF1 ; $y++) {
            if ($columnF1[$y] =~ "C\/A"){
                $columnF1[$y] = "A\/C"
            }
            elsif ($columnF1[$y] =~ "G\/A"){
                $columnF1[$y] = "A\/G"
            }
            elsif ($columnF1[$y] =~ "T\/A"){
                $columnF1[$y] = "A\/T"
            }
            elsif ($columnF1[$y] =~ "C\/G"){
                $columnF1[$y] = "G\/C"
            }
            elsif ($columnF1[$y] =~ "T\/C"){
                $columnF1[$y] = "C\/T"
            }
            elsif ($columnF1[$y] =~ "T\/G"){
                $columnF1[$y] = "G\/T"
            }
#           print $columnF1[$y],"\n";
        }
        if(($columnF1[$mom] =~ /\.+/)&&($columnF1[$dad] =~ /\.+/)){
            # this site is missing genotypes from both parents 
            #but checking if potentially sex-linked in offspeing (coverage issues):
                #- heteroz in one sex, homoz in the other 
                #- nothing in one sex but homoz in the other 

            @daughter_genotypes=();  #need to clear the array for both sex each time (or we add the genotypes each line after each line)
            for ($y = 0 ; $y <= $#girls ; $y++ ) { 
                if($columnF1[$girls[$y]] !~ /\.+/ ){
                    push(@daughter_genotypes, $columnF1[$girls[$y]]);
                }
            }
            @son_genotypes=();
            for ($y = 0 ; $y <= $#boys ; $y++ ) { 
                if($columnF1[$boys[$y]] !~ /\.+/){
                    # a genotype call is present for this boy
                    push(@son_genotypes, $columnF1[$boys[$y]]);
                    print "boys ",$columnF1[$boys[$y]],"\n";
                }
            }
            @unique_daughters = uniq(@daughter_genotypes);
            @unique_sons = uniq(@son_genotypes);
#add a criteria for the number of genotypes needed in order to consider this site
            if((($#unique_daughters == 0)&&($#unique_sons == 0))
                && (($#daughter_genotypes > $minimum_number_of_genotypes_from_daughters)||
                ($#son_genotypes > $minimum_number_of_genotypes_from_sons))){
                # this could be sex linked (length of array = 1 -> one genotype only on each sex); now check if only one is a homoz
                if(((grep $_ eq  $unique_daughters[0], @homozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))||
                    ((grep $_ eq $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @homozygous_genotypes))
                    ){
                    #Distinguish "polymorphic" sex-linked male and female
                    if (grep $_ eq $unique_daughters[0], @heterozygous_genotypes){ 
                        print OUTFILE1 "Heterozygous_daughters_no_parent_data ",$line1,"\n";
                    }
                    if (grep $_ eq $unique_sons[0], @heterozygous_genotypes){
                                                print OUTFILE1 "Heterozygous_sons_no_parent_data ",$line1,"\n";
                                        }

                    foreach (@unique_daughters){
                        push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$_);
                        push (@{$polymorphic_sites_daughter_only{$columnF1[0]}},$columnF1[1]); #at least one sex heteroz
                        print OUTFILE3 "polymorphic_sites_daughter_only ",$line1,"\n";

                    }
                            foreach (@unique_sons){
                                push (@{$unique_son_geno{ $columnF1[0]}{$columnF1[1]}},$_);
                                push (@{$polymorphic_sites_son_only{$columnF1[0]}},$columnF1[1]); #at least one sex heteroz
                                                  print OUTFILE3 "polymorphic_sites_son_only ",$line1,"\n";
                            }
                }
            }
            elsif(($#daughter_genotypes == -1)||($#son_genotypes == -1)){  # $# = null list -> we have missing data or no geno for one sex (sites spec for one sex)
            # there is more than a minimum number of genotypes for only one sex and there are none for the other
            # this is especially interesting for W-linked if it is only daughters.

                if($#son_genotypes >= $minimum_number_of_genotypes_from_sons){
                    print OUTFILE3 "polymorphic_sites_son_only ",$line1,"\n";
                    push (@{$polymorphic_sites_son_only{$columnF1[0]}},$columnF1[1]); #one sex no geno, other yes 
                    print OUTFILE1 "Only_sons_XY ",$line1,"\n";
                        foreach (@unique_sons){
                            push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$_);
                        }
                }   
                elsif($#daughter_genotypes >= $minimum_number_of_genotypes_from_daughters){
                    print OUTFILE3 "polymorphic_sites_daughter_only ",$line1,"\n";
                    push (@{$polymorphic_sites_daughter_only{$columnF1[0]}},$columnF1[1]); #one sex no geno, other yes 
                    print OUTFILE1 "Only_daughters_ZW ",$line1,"\n";
                        foreach (@unique_daughters){
                            push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$_);
                        }
                }
            }
            else{
                #push (@{$polymorphic_sites_daughter_only{$columnF1[0]}},$columnF1[1]); #SEE IF OK or add criteria
                #push (@{$polymorphic_sites_son_only{$columnF1[0]}},$columnF1[1]); #SEE IF OK
                #print OUTFILE3 "polymorphic_sites_children_only ",$line1,"\n"; #print sites where a few individuals have homozygous sites, see with Ben if we should add smthg there
                print OUTFILE2 $line1,"\n";
            }
        }


        ##Data for mom and dad. One is heteroz, the other homoz. Check if in the offspring we have only (or almost) one genotype for each sex. 
        #Looking for sites on the PAR of the hemizygous chromosome (W or Y)
        #Or sites on Z, not present on the W (male: ZZ heteroz, female: Z homoz) 

        elsif(((grep $_ eq $columnF1[$mom], @homozygous_genotypes) && (grep $_ eq $columnF1[$dad], @heterozygous_genotypes)) ||
        ((grep $_ eq $columnF1[$mom], @heterozygous_genotypes) && (grep $_ eq $columnF1[$dad], @homozygous_genotypes))
            ){ ##Compare homoz/heteroz combinations defined before with our data
            ##Check for missing data in children data, keep the genotype if no missing data. Then find sites only present in one sex 

            ##Check that genotype of the children can be made from the genotype of the parents (no nucleotide absent in the parents appears in the children or = sequencing errors /diff cov.))

                    $geno_mom_dad = join ("\t",$columnF1[$mom],$columnF1[$dad]);
                    print "geno_mom_dad \$",$geno_mom_dad,"\n";
                    print "geno_mom_dad mom",$columnF1[$mom],"\n";
                    print "geno_mom_dad dad",$columnF1[$dad],"\n";
                    @geno_mom_dad = split /["\t"\/]/, $geno_mom_dad ;
                    print "geno_mom_dad \@", @geno_mom_dad,"\n";

            @daughter_genotypes=();
            for ($y = 0 ; $y <= $#girls ; $y++ ) { 
                if($columnF1[$girls[$y]] ne "\."){
                    $geno_mom_dad = join ("\t",$columnF1[$mom],$columnF1[$dad]);
                    @geno_mom_dad = split /["\t"\/]/, $geno_mom_dad;
                    #print "geno_mom_dad ", @geno_mom_dad;
                    @temp = split /[\/]/, $columnF1[$girls[$y]];
                    if ((grep $_ eq $temp[0], @geno_mom_dad)&&(grep $_ eq $temp[1], @geno_mom_dad)){
                    # a genotype call is present for this girl
                        push(@daughter_genotypes, $columnF1[$girls[$y]]);
                        print "girl geno ", $columnF1[$girls[$y]],"\n";
                    }
                }
            }
            @son_genotypes=();
            for ($y = 0 ; $y <= $#boys ; $y++ ) { 
                if($columnF1[$boys[$y]] ne "\."){
                    $geno_mom_dad = join ("\t",$columnF1[$mom],$columnF1[$dad]);
                    @geno_mom_dad = split /["\t"\/]/, $geno_mom_dad;
                    @temp = split /[\/]/, $columnF1[$boys[$y]];
                    # a genotype call is present for this boy
                    if ((grep $_ eq $temp[0], @geno_mom_dad)&&(grep $_ eq $temp[1], @geno_mom_dad)){
                        push(@son_genotypes, $columnF1[$boys[$y]]);
                    }
                }
            }
            @unique_daughters = uniq(@daughter_genotypes);
            @unique_sons = uniq(@son_genotypes);

            if (grep $_ eq $columnF1[$mom], @heterozygous_genotypes){
                push (@{$polymorphic_sites_mom{$columnF1[0]}},$columnF1[1]);
                print OUTFILE3 "polymorphic_sites_mom ",$line1,"\n";
            }

            if (grep $_ eq $columnF1[$dad], @heterozygous_genotypes){
                push (@{$polymorphic_sites_dad{$columnF1[0]}},$columnF1[1]);
                print "The supercontig POLYM position is ",$columnF1[1],"\n";
                print OUTFILE3 "polymorphic_sites_dad ",$line1,"\n";
            }

            if(($#unique_daughters == 0)&&($#unique_sons == 0)){
                # this could be sex linked (length of array = 1 -> one genotype only on each sex); now check if only one is a homoz
                if(((grep $_ eq  $unique_daughters[0], @homozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))||
                    ((grep $_ eq $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @homozygous_genotypes))
                    ){
                    if ((grep $_ eq $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                        print OUTFILE1 "Heterozygous_daughters_mom_ZW ",$line1,"\n";
                    }
                    if ((grep $_ eq $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                print OUTFILE1 "Heterozygous_daughters_dad_XY ",$line1,"\n";
                                        }
                    if ((grep $_ eq $unique_sons[0], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                print OUTFILE1 "Heterozygous_sons_dad_XY ",$line1,"\n";
                                        }
                    if ((grep $_ eq $unique_sons[0], @heterozygous_genotypes)&& (grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                print OUTFILE1 "Heterozygous_sons_mom_ZW ",$line1,"\n";
                                        }

                    #push (@{$polymorphic_sites{$columnF1[0]}},$columnF1[1]); #1 geno per sex but 1 heteroz

                    foreach (@unique_daughters){
                        push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$_);
                    }
                             foreach (@unique_sons){
                                     push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$_);
                             }
                }

                ##Add here if one parent homoz, the other heteroz. The offspring: both heteroz (ZZ: AA, ZW: GT -> ZZ: AT, ZW: AG)
                elsif(((grep $_ eq  $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))&&
                    ($unique_daughters[0] ne $unique_sons[0])
                    ){
                        print OUTFILE1 "Heterozygous_both_offspring ",$line1,"\n";

                        #push (@{$polymorphic_sites{$columnF1[0]}},$columnF1[1]); #offspring heteroz

                            foreach (@unique_daughters){
                                push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$_);

                            }
                                        foreach (@unique_sons){
                                            push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$_);

                                        }
                }
                else{
                    #push (@{$polymorphic_sites{$columnF2[0]}},$columnF2[1]); # one genotype per sex within the offspring 
                    print OUTFILE2 $line1,"\n";
                }

            }
            # Now test whether this site is "almost sex linked" because a low number of possible genotype errors exist
            # need $#unique_daughters == 1; if more will not work because we stop at the major or if not the other one
            #elsif (($#unique_daughters > 0)||($#unique_sons > 0)){
            elsif (($#unique_daughters == 1)||($#unique_sons == 1)){
            #push (@{$polymorphic_sites{$columnF2[0]}},$columnF2[1]); #more than one genotype

            $first_genotype_daughters=1;
            $first_genotype_sons=1;
                for ($y = 1 ; $y <= $#daughter_genotypes ; $y++ ) {
                    if($daughter_genotypes[0] eq $daughter_genotypes[$y]){
                        $first_genotype_daughters+=1;
                    }
                }
                for ($y = 1 ; $y <= $#son_genotypes ; $y++ ) {
                    if($son_genotypes[0] eq $son_genotypes[$y]){
                        $first_genotype_sons+=1;
                    }
                }

                    if (($#daughter_genotypes!=-1 && $#son_genotypes!=-1)&&
                                           (((($#daughter_genotypes+1)*($first_genotype_daughters/($#daughter_genotypes+1)))>$minimum_number_of_genotypes_from_daughters))){
                        if ((($#son_genotypes+1)*(($first_genotype_sons)/($#son_genotypes+1)))>$minimum_number_of_genotypes_from_sons){
                            if ($daughter_genotypes[$first_genotype_daughters-1] ne $son_genotypes[$first_genotype_sons-1]){
                                if (((grep $_ eq $daughter_genotypes[$first_genotype_daughters-1], @heterozygous_genotypes) && 
                                                           (grep $_ eq $son_genotypes[$first_genotype_sons-1], @homozygous_genotypes)) ||
                                                             ((grep $_ eq $daughter_genotypes[$first_genotype_daughters-1], @homozygous_genotypes) && 
                                                                          (grep $_ eq $son_genotypes[$first_genotype_sons-1], @heterozygous_genotypes)) 
                                                                           ){

                                        push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$daughter_genotypes[$first_genotype_daughters-1]);

                                        push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$son_genotypes[$first_genotype_sons-1]);
                                        if ((grep $_ eq $daughter_genotypes[$first_genotype_daughters-1], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                                            print OUTFILE1 "Heterozygous_daughters_mom_ZW ",$line1,"\n";
                                                                    }
                                                            if ((grep $_ eq $daughter_genotypes[$first_genotype_daughters-1], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                                    print OUTFILE1 "Heterozygous_daughters_dad_XY ",$line1,"\n";
                                                            }
                                                            if ((grep $_ eq $son_genotypes[$first_genotype_sons-1], @heterozygous_genotypes)&& (grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                                    print OUTFILE1 "Heterozygous_sons_mom_ZW ",$line1,"\n";
                                                            }
                                        if ((grep $_ eq $son_genotypes[$first_genotype_sons-1], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                print OUTFILE1 "Heterozygous_sons_dad_XY ",$line1,"\n";
                                        }
                                }   
                                }
                        }
                        elsif ((($#son_genotypes+1)*(($#son_genotypes+1-$first_genotype_sons)/($#son_genotypes+1)))>$minimum_number_of_genotypes_from_sons){
                            if ($daughter_genotypes[$first_genotype_daughters-1] ne $son_genotypes[$#son_genotypes-$first_genotype_sons]){
                                                                if (((grep $_ eq $daughter_genotypes[$first_genotype_daughters-1], @heterozygous_genotypes) &&
                                                                       (grep $_ eq $son_genotypes[$#son_genotypes-$first_genotype_sons], @homozygous_genotypes)) ||
                                                                         ((grep $_ eq $daughter_genotypes[$first_genotype_daughters-1], @homozygous_genotypes) &&
                                                                          (grep $_ eq $son_genotypes[$#son_genotypes-$first_genotype_sons], @heterozygous_genotypes))                        
                                                                           ){
                                        push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$daughter_genotypes[$first_genotype_daughters-1]);   
                                        push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$son_genotypes[$#son_genotypes-$first_genotype_sons]);
                                                                    if ((grep $_ eq $daughter_genotypes[$first_genotype_daughters-1], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                                            print OUTFILE1 "Heterozygous_daughters_mom_ZW ",$line1,"\n";
                                                                    }
                                                                    if ((grep $_ eq $daughter_genotypes[$first_genotype_daughters-1], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                                            print OUTFILE1 "Heterozygous_daughters_dad_XY ",$line1,"\n";
                                                                    }
                                                                    if ((grep $_ eq $son_genotypes[$#son_genotypes-$first_genotype_sons], @heterozygous_genotypes)&& (grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                                            print OUTFILE1 "Heterozygous_sons_mom_ZW ",$line1,"\n";
                                                                    }
                                                                    if ((grep $_ eq $son_genotypes[$#son_genotypes-$first_genotype_sons], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                                            print OUTFILE1 "Heterozygous_sons_dad_XY ",$line1,"\n";
                                                                    }
                                                        }
                                            }
                                        }
                    }#$first_genotype_daughters

                    elsif (($#daughter_genotypes!=-1 && $#son_genotypes!=-1)&&(($#daughter_genotypes+1)*(($#daughter_genotypes+1-$first_genotype_daughters)/($#daughter_genotypes+1)))>$minimum_number_of_genotypes_from_daughters){
                        if ((($#son_genotypes+1)*(($first_genotype_sons)/($#son_genotypes+1)))>$minimum_number_of_genotypes_from_sons){
                                                        if ($daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters] ne $son_genotypes[$first_genotype_sons-1]){
                                                                if (((grep $_ eq $daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters], @heterozygous_genotypes) &&
                                                                       (grep $_ eq $son_genotypes[$first_genotype_sons-1], @homozygous_genotypes)) ||
                                                                         ((grep $_ eq $daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters], @homozygous_genotypes) &&
                                                                          (grep $_ eq $son_genotypes[$first_genotype_sons-1], @heterozygous_genotypes))                        
                                                                           ){
                                    push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters]);
                                    push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$son_genotypes[$first_genotype_sons-1]);
                                                                    if ((grep $_ eq $daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                                           print OUTFILE1 "Heterozygous_daughters_mom_ZW ",$line1,"\n";
                                                                    }
                                                                    if ((grep $_ eq $daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                                            print OUTFILE1 "Heterozygous_daughters_dad_XY ",$line1,"\n";
                                                                    }   
                                                                    if ((grep $_ eq $son_genotypes[$first_genotype_sons-1], @heterozygous_genotypes)&& (grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                                            print OUTFILE1 "Heterozygous_sons_mom_ZW ",$line1,"\n";
                                                                    }
                                                                    if ((grep $_ eq $son_genotypes[$first_genotype_sons-1], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                                            print OUTFILE1 "Heterozygous_sons_dad_XY ",$line1,"\n";
                                                                    }
                                                        }
                                                }
                                            }
                                            if ((($#son_genotypes+1)*(($#son_genotypes+1-$first_genotype_sons)/($#son_genotypes+1)))>$minimum_number_of_genotypes_from_sons){
                                                    if ($daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters] ne $son_genotypes[$#son_genotypes-$first_genotype_sons]){
                                                                if (((grep $_ eq $daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters], @heterozygous_genotypes) &&
                                                                       (grep $_ eq $son_genotypes[$#son_genotypes-$first_genotype_sons], @homozygous_genotypes)) ||
                                                                         ((grep $_ eq $daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters], @homozygous_genotypes) &&
                                                                          (grep $_ eq $son_genotypes[$#son_genotypes-$first_genotype_sons], @heterozygous_genotypes))  
                                                                           ){
                                                                                push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$daughter_genotypes[$first_genotype_daughters-1]);
                                                                                push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$son_genotypes[$#son_genotypes-$first_genotype_sons]);
                                                                                if ((grep $_ eq $daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                                                print OUTFILE1 "Heterozygous_daughters_mom_ZW ",$line1,"\n";
                                                                                }
                                                                                if ((grep $_ eq $daughter_genotypes[$#daughter_genotypes-$first_genotype_daughters], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                                                print OUTFILE1 "Heterozygous_daughters_dad_XY ",$line1,"\n";
                                                                                }
                                                                                if ((grep $_ eq $son_genotypes[$#son_genotypes-$first_genotype_sons], @heterozygous_genotypes)&& (grep $_ eq $columnF1[$mom], @heterozygous_genotypes)){
                                                                                print OUTFILE1 "Heterozygous_sons_mom_ZW ",$line1,"\n";
                                                                                }
                                                                                if ((grep $_ eq $son_genotypes[$#son_genotypes-$first_genotype_sons], @heterozygous_genotypes)&&(grep $_ eq $columnF1[$dad], @heterozygous_genotypes)){
                                                                                print OUTFILE1 "Heterozygous_sons_dad_XY ",$line1,"\n";
                                                                                }
                                                                }
                                                }
                                        }
                                        #}
                        #else{
                    #print OUTFILE2 $line2,"\n";
                    #}
                #}

                ###Looking for sites that are on the X or Z chromosomes and not on the other XX AT x XY A. -> XX AA/AT XY A./T.
                if(($#unique_daughters == 1)&&($#unique_sons == 1)){
                    if
                     (((grep $_ eq $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_daughters[1], @homozygous_genotypes)&&
                    (grep $_ eq $unique_sons[0], @homozygous_genotypes)&&(grep $_ eq $unique_sons[1], @homozygous_genotypes))||
                    ((grep $_ eq $unique_daughters[1], @heterozygous_genotypes)&&(grep $_ eq $unique_daughters[0], @homozygous_genotypes)&&
                                        (grep $_ eq $unique_sons[0], @homozygous_genotypes)&&(grep $_ eq $unique_sons[1], @homozygous_genotypes))){
                                                print OUTFILE1 "XY_system_Xsites ",$line1,"\n";
                                        }
                    if (((grep $_ eq $unique_daughters[0], @homozygous_genotypes)&&(grep $_ eq $unique_daughters[1], @homozygous_genotypes)&&
                                        (grep $_ eq $unique_sons[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[1], @homozygous_genotypes))||
                    ((grep $_ eq $unique_daughters[0], @homozygous_genotypes)&&(grep $_ eq $unique_daughters[1], @homozygous_genotypes)&&
                                        (grep $_ eq $unique_sons[1], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @homozygous_genotypes))){
                                                print OUTFILE1 "ZW_system_Zsites ",$line1,"\n";
                                        }
                }
                }
                else{
                print OUTFILE2 $line1,"\n";
                }
            }
            #else{
            #print OUTFILE2 $line1,"\n";
            #}
        } # end of elsif to check if only one parent is heterozygous

        ## Both parents are heterozygous
        elsif(((grep $_ eq $columnF1[$mom], @heterozygous_genotypes) && (grep $_ eq $columnF1[$dad], @heterozygous_genotypes)) 
            ){

            #push (@{$polymorphic_sites{$columnF2[0]}},$columnF2[1]); #parents heteroz

            push (@{$polymorphic_sites_mom{$columnF1[0]}},$columnF1[1]);
            push (@{$polymorphic_sites_dad{$columnF1[0]}},$columnF1[1]);
            print OUTFILE3 "polymorphic_sites_mom_and_dad ",$line1,"\n";
            print "The supercontig POLYM position is ",$columnF1[1],"\n";

            @daughter_genotypes=();
            @son_genotypes=();
            for ($y = 0 ; $y <= $#girls ; $y++ ) { 
                if($columnF1[$girls[$y]] ne "\.") {
                    $geno_mom_dad = join ("\t",$columnF1[$mom],$columnF1[$dad]);
                    @geno_mom_dad = split /["\t"\/]/, $geno_mom_dad;
                    @temp = split /[\/]/, $columnF1[$girls[$y]];
                    if ((grep $_ eq $temp[0], @geno_mom_dad)&&(grep $_ eq $temp[1], @geno_mom_dad)){
                        push(@daughter_genotypes, $columnF1[$girls[$y]]);
                    }
                }
            }

            for ($y = 0 ; $y <= $#boys ; $y++ ) { 
                if ($columnF1[$boys[$y]] ne "\."){
                    $geno_mom_dad = join ("\t",$columnF1[$mom],$columnF1[$dad]);
                    @geno_mom_dad = split /["\t"\/]/, $geno_mom_dad;
                    @tempB = split /[\/]/, $columnF1[$boys[$y]];
                    if ((grep $_ eq $tempB[0], @geno_mom_dad)&&(grep $_ eq $tempB[1], @geno_mom_dad)){
                        push(@son_genotypes, $columnF1[$boys[$y]]);
                    }
                }
            }
        #}
                    @unique_daughters = uniq(@daughter_genotypes);
                    @unique_sons = uniq(@son_genotypes);
                    if(($#unique_daughters == 1)&&($#unique_sons == 1)){
                        if (((($unique_daughters[0]) ne ($unique_sons[0])) && (($unique_daughters[1]) ne ($unique_sons[1])))&&
                            ((($unique_daughters[0]) ne ($unique_sons[1])) && (($unique_daughters[1]) ne ($unique_sons[0])))){
                            #ZZ:AT ZW:CG -> ZZ:AC/TC ZW:AG/TG (everybody is heterozygous)
                            if (((grep $_ eq  $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))&&
                            ((grep $_ eq $unique_daughters[1], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[1], @heterozygous_genotypes))
                            ){ 
                                print OUTFILE1 $line1,"\n";
                                    foreach (@unique_daughters){
                                        push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$_);

                                    }
                                    foreach (@unique_sons){
                                                    push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$_);
                                                }
                                    }
                            #ZZ:AT ZW:TG -> ZZ:AT/TT ZW:AG/TG (everybody is heterozygous except one group of children)
                            #1st:1group of females homoz [1]
                                    elsif ((((grep $_ eq  $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))&&
                            ((grep $_ eq $unique_daughters[1], @homozygous_genotypes)&&(grep $_ eq $unique_sons[1], @heterozygous_genotypes))) ||
                            #2nd:1group of females homoz [0]
                            (((grep $_ eq  $unique_daughters[0], @homozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))&&
                            ((grep $_ eq $unique_daughters[1], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[1], @heterozygous_genotypes))) ||
                            #3rd:1group of males homoz [0]
                            (((grep $_ eq  $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @homozygous_genotypes))&&
                            ((grep $_ eq $unique_daughters[1], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[1], @heterozygous_genotypes))) ||
                            #4th:1group of males homoz [1]
                            (((grep $_ eq  $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))&&
                            ((grep $_ eq $unique_daughters[1], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[1], @homozygous_genotypes)))
                            ){ 
                                print OUTFILE1 "Multiple_genotypes ",$line1,"\n";
                                    foreach (@unique_daughters){
                                        push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$_);

                                    }
                                    foreach (@unique_sons){
                                                    push (@{$unique_son_geno{ $columnF1[0]}{$columnF1[1]}},$_);

                                                }
                                        }
                                    else{
                                print OUTFILE2 $line1,"\n";
                            }
                                }
                                else{
                            print OUTFILE2 $line1,"\n";
                        }
                    }
                    #We have more data for the parents so if we have ZZ: CA (heteroz) & ZW:A/. -> children: ZZ:AA(homoz) and ZW:C/. (not enough data to call homoz A)
                    elsif((($#unique_daughters==-1 && $#unique_sons==0)||
                                    ($#unique_daughters==0 && $#unique_sons==-1))
                    && (($#daughter_genotypes > $minimum_number_of_genotypes_from_daughters)||
                                    ($#son_genotypes > $minimum_number_of_genotypes_from_sons))){
                                            if ((grep $_ eq $unique_daughters[0],@homozygous_genotypes)||
                                            (grep $_ eq $unique_sons[0],@homozygous_genotypes)){
                            if (grep $_ eq $unique_daughters[0],@homozygous_genotypes){
                                                        print OUTFILE1 "Probably_XY ",$line1,"\n";
                            }
                            if (grep $_ eq $unique_sons[0],@homozygous_genotypes){
                                                                print OUTFILE1 "Probably_ZW ",$line1,"\n";
                                                        }
                                                    foreach (@unique_daughters){
                                                            push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$_);
                                                    }
                                                    foreach (@unique_sons){
                                                            push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$_);
                                                    }
                                            }
                                    }   
                                    else{
                                    print OUTFILE2 $line1,"\n";
                                    }
                        # }
                       # else{
                       # print OUTFILE2 $line1,"\n";
                       # }

                #   else{
                #   print OUTFILE2 $line2,"\n";
                #   }
                #}
                #else{
                #print OUTFILE2 $line2,"\n";
                #}
            #}
        }

        ## now check: no missing data, both homoz: check if potential sex-linked pattern in offspring: one sex homoz & one heteroz (pb of cov): +do it with heteroz/heteroz that it is a possible heteroz in off

        elsif (((grep $_ eq $columnF1[$mom], @homozygous_genotypes) && (grep $_ eq $columnF1[$dad], @homozygous_genotypes)) 
            ){
            @daughter_genotypes=();
            @son_genotypes=();
            for ($y = 0 ; $y <= $#girls ; $y++ ) { 
                if($columnF1[$girls[$y]]!~/\.+/) {
                    push(@daughter_genotypes, $columnF1[$girls[$y]]);
                }
            }
            for ($y = 0 ; $y <= $#boys ; $y++ ) { 
                if($columnF1[$boys[$y]] !~/\.+/){
                    # a genotype call is present for this boy
                    push(@son_genotypes, $columnF1[$boys[$y]]);
                }
            }
            @unique_daughters = uniq(@daughter_genotypes);
            @unique_sons = uniq(@son_genotypes);

            if((($#unique_daughters == 0)&&($#unique_sons == 0))
                && (($#daughter_genotypes > $minimum_number_of_genotypes_from_daughters)||
                                ($#son_genotypes > $minimum_number_of_genotypes_from_sons))){
                # this could be sex linked (length of array = 1 -> one genotype only on each sex); now check if only one is a homoz
                if(((grep $_ eq  $unique_daughters[0], @homozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))||
                ((grep $_ eq $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @homozygous_genotypes))
                ){

#                   push (@{$polymorphic_sites{$columnF1[0]}},$columnF1[1]); #one sex heteroz
                    if (grep $_ eq $unique_daughters[0], @heterozygous_genotypes){
                        print OUTFILE1 "Heterozygous_daughters_probably_XY ",$line1,"\n";
                        print OUTFILE3 "polymorphic_sites_daughter_only ",$line1,"\n";
                    }
                    if (grep $_ eq $unique_sons[0], @heterozygous_genotypes){
                                                print OUTFILE1 "Heterozygous_sons_probably_ZW ",$line1,"\n";
                        print OUTFILE3 "polymorphic_sites_son_only ",$line1,"\n";
                                        }
                        foreach (@unique_daughters){
                            push (@{$unique_daug_geno{ $columnF1[0]}{$columnF1[1]}},$_);

                        }
                        foreach (@unique_sons){
                            push (@{$unique_son_geno{ $columnF1[0]}{$columnF1[1]}},$_);
                        }
                }
                else{
                print OUTFILE2 $line1,"\n";
                }
            }

            else{
                print OUTFILE2 $line1,"\n";
            }
        }


        elsif(

        ##Check if one parent is homozygous or heterozygous and the other is a dot "." (missing data in vcf files). 
        #Looking for sites on the hemizygous chromosome. (present in one copy in one sex)

        (($columnF1[$mom] !~ /\.+/)&&($columnF1[$dad] =~ /\.+/))||
        (($columnF1[$mom] =~ /\.+/)&&($columnF1[$dad] !~/\.+/))
        ){
        @daughter_genotypes=();
        @son_genotypes=();
        # now check if all heterozygotes are only in one sex and all homozygotes are only in the other sex
        # but allow for missing calls

            for ($y = 0 ; $y <= $#girls ; $y++ ) { 
                if($columnF1[$girls[$y]] !~ /\.+/){
            # a genotype call is present for this girl
                    push(@daughter_genotypes, $columnF1[$girls[$y]]);
                }
            }
            for ($y = 0 ; $y <= $#boys ; $y++ ) { 
                if($columnF1[$boys[$y]] !~ /\.+/){
            # a genotype call is present for this boy   
                    push(@son_genotypes, $columnF1[$boys[$y]]);
                }
            }
                # now check if one sex is all heterozygotes and the other
                # is all homozygotes.

            @unique_daughters = uniq(@daughter_genotypes);
            @unique_sons = uniq(@son_genotypes);
            #print "@unique_daughters @unique_sons";
            #print " ",$#unique_daughters," ",$#unique_sons,"\n";
            if((($#unique_daughters == 0)&&($#unique_sons == 0))
                && (($#daughter_genotypes > $minimum_number_of_genotypes_from_daughters)||
                            ($#son_genotypes > $minimum_number_of_genotypes_from_sons))){ #check if after unique we only have one genotype (#$==0)
                #print "@unique_daughters @unique_sons\n";
                if(((grep $_ eq $unique_daughters[0], @homozygous_genotypes)&&(grep $_ eq $unique_sons[0], @heterozygous_genotypes))||
                ((grep $_ eq $unique_daughters[0], @heterozygous_genotypes)&&(grep $_ eq $unique_sons[0], @homozygous_genotypes))
                ){
            # eventually add another check to confirm that the sex specific genotypes could actually be derived from the parents
            # for which a genotype was inferred

                    #push (@{$polymorphic_sites{$columnF1[0]}},$columnF1[1]); #one sex heteroz
                    if (grep $_ eq $unique_daughters[0], @heterozygous_genotypes){
                        push (@{$polymorphic_sites_daughter_only{$columnF1[0]}},$columnF1[1]);
                        print OUTFILE3 "polymorphic_sites_daughter_only ",$line1,"\n";
                        print OUTFILE1 "Heterozygous_daughters ",$line1,"\n";
                    }

                    if (grep $_ eq $unique_sons[0], @heterozygous_genotypes){
                        push (@{$polymorphic_sites_son_only{$columnF1[0]}},$columnF1[1]);
                        print OUTFILE3 "polymorphic_sites_son_only ",$line1,"\n";
                        print OUTFILE1 "Heterozygous_sons ",$line1,"\n";
                    }


                    #print OUTFILE1 $line1,"\n";
                        foreach (@unique_daughters){
                                    push (@{$unique_daug_geno{$columnF1[0]}{$columnF1[1]}},$_);
                            #print "hello ",$columnF1[0],"\t",$columnF1[1],"\t",$_,"\n";

                                }
                                foreach (@unique_sons){
                                    push (@{$unique_son_geno{$columnF1[0]}{$columnF1[1]}},$_);
                                    }
                }#if grep genotype potentially sex-linked
                else{
                print OUTFILE2 $line1,"\n";
                }
            }#if only one genotype in one sex
            elsif(($#daughter_genotypes == -1)||($#son_genotypes == -1)){  # $# = null list -> we have missing data or no geno for one sex (sites spec for one sex)
                if(($#daughter_genotypes >= $minimum_number_of_genotypes_from_daughters)||
                ($#son_genotypes >= $minimum_number_of_genotypes_from_sons)){ #check that it is sex-linked and not only poor coverage or seq error 
            # there is more than a minimum number of genotypes for only one sex and there are none for the other
            # this is especially interesting for W-linked if it is only daughters.

                    #push (@{$polymorphic_sites{$columnF1[0]}},$columnF1[1]); #one no data, other yes

                    if ($columnF1[$mom] !~ /\.+/){ #XY
                        push (@{$polymorphic_sites_mom{$columnF1[0]}},$columnF1[1]);
                        print OUTFILE3 "polymorphic_sites_mom ",$line1,"\n";
                    }

                    if ($columnF1[$dad] !~ /\.+/){ #ZW
                        push (@{$polymorphic_sites_dad{$columnF1[0]}},$columnF1[1]);
                        print "The supercontig POLYM position is ",$columnF1[1],"\n";
                        print OUTFILE3 "polymorphic_sites_dad ",$line1,"\n";
                    }

                    if(($#unique_daughters == -1)&&($columnF1[$mom] =~ /\.+/)){
                        print OUTFILE1 "Only_sons_XY ",$line1,"\n";
                            foreach (@unique_sons){
                                push (@{$unique_son_geno{ $columnF1[0]}{$columnF1[1]}},$_);
                            }
                    }   
                    elsif(($#son_genotypes == -1)&&($columnF1[$dad] =~ /\.+/)){
                        print OUTFILE1 "Only_daughters_ZW ",$line1,"\n";
                            foreach (@unique_daughters){
                                push (@{$unique_daug_geno{ $columnF1[0]}{$columnF1[1]}},$_);
                            #   print "hello ",$columnF1[0],"\t",$columnF1[1],"\t",$_,"\n";
                            }

                    }
                } #if good number of genotypes
                else{
                print OUTFILE2 $line1,"\n";
                }
            } #elsif missing data

            else{
                #SEE if informative to add somtg polym here
            #   push (@{$polymorphic_sites{$columnF2[0]}},$columnF2[1]); #more genotypes than 1
                print OUTFILE2 $line1,"\n";

                if ($#unique_daughters > 1){ #XY
                    push (@{$polymorphic_sites_daughter_only{$columnF1[0]}},$columnF1[1]);
                                                  print OUTFILE3 "polymorphic_sites_daughter_only ",$line1,"\n";
                }

                if ($#unique_sons > 1){ #ZW
                    push (@{$polymorphic_sites_son_only{$columnF1[0]}},$columnF1[1]);
                                                  print OUTFILE3 "polymorphic_sites_son_only ",$line1,"\n";
                }
            }
            #else{
            # both are heterozygous; 
            # check if a homozygote class is only in one sex, and never in the other
            #}
        }
        else{
        print OUTFILE2 $line1,"\n";
        }
    }
}

close DATAINPUT1;
print "Done with input file 1\n";
close DATAINPUT2;
print "Done with input file 2\n";
close OUTFILE3;
print "Done with outputfile 3\n";
close OUTFILE2;
print "Done with outputfile 2\n";
close OUTFILE1;
print "Done with outputfile 1\n";

```
Time: `934.090u 11.955s 15:52.24 99.3% 0+0k 2917256+1816624io 0pf+0w`.

`main.cpp`
To compile: 
```
setenv LD_LIBRARY_PATH /home/evanslab/Hymeno_fastqc/gcc-6.2.0/lib64
echo $LD_LIBRARY_PATH
```
`3rd_part.pl`
```perl
#!/usr/local/perl5.24/perl-5.24.0/perl

use strict;
use warnings;
use List::MoreUtils qw/ uniq /;
use List::Util qw(min max);

# This script reads in a tab delimited files that contains information
# for each scaffolds. It selects potential sex-linked scaffolds that will
# be used later as input of blast. It uses a genome reference in a fasta format.

##INPUT files
my $inputfile = "count.txt";

unless (open DATAINPUT, $inputfile) {
        print "Can not find the input file $inputfile, jackass.\n";
        exit;
}

my $inputfile1 = "Sample_SOAP_seq.fa";

unless (open DATAINPUT1, $inputfile1) {
        print "Can not find the input file $inputfile1, jackass.\n";
        exit;
}

##OUTPUT file

my $outputfile = "Hymenochirus_putative_sex_linked_opt.fa";

unless(open(OUTFILE, ">$outputfile")){
        print "I can\'t write to $outputfile   $!\n\n";
        exit;
}


my @column;
my $minimum_total_called_sites = 15;
my $minimum_total_number_SS_calls=1;
my $minimum_total_polymorphic_sites=2;
my $ratio_geno_poly_limit=0.05;
my $number_geno_tot;
my $number_XY_sites;
my $number_Y_only_sites;
my $number_ZW_sites;
my $number_W_only_sites;
my $number_polym_mom;
my $number_polym_dad;
my $number_polym_daughter_only;
my $number_polym_son_only;
my $size;
my @fasta_names_XY;
my @fasta_names_Y;
my @fasta_names_ZW;
my @fasta_names_W;
my $scaffold_name;

print "Starting checking the scaffolds","\n";

while (my $line = <DATAINPUT>){
        chomp($line);
        @column=split('\t',$line);
        $scaffold_name = $column[0];
        $number_geno_tot = $column[1];
        $number_XY_sites = $column[2];
        $number_Y_only_sites = $column[3];
        $number_ZW_sites = $column[4];
        $number_W_only_sites = $column[5];
        $number_polym_mom = $column[6];
        $number_polym_dad = $column[7];
        $number_polym_daughter_only = $column[8];
        $number_polym_son_only = $column[9];
        $size = $column[10];
        print "columns count ",$scaffold_name,"\t",$number_geno_tot, "\t","XY system ",$number_XY_sites, "\t", $number_Y_only_sites,"\n","ZW system ",$number_ZW_sites,"\t", $number_W_only_sites, "\n",
        "polym ","\t",$number_polym_mom, "\t", $number_polym_dad,"\t",$number_polym_daughter_only,"\t", $number_polym_son_only,"\n";
        if (($number_geno_tot >= $minimum_total_called_sites) && 
                ($number_polym_dad > $minimum_total_polymorphic_sites) &&
                ($number_XY_sites > $minimum_total_number_SS_calls) &&
                ($number_XY_sites > $number_ZW_sites) &&
                ($number_XY_sites / $number_polym_dad > $ratio_geno_poly_limit)){
                print "ratio ", $number_XY_sites / $number_polym_dad,"\n";
                        if ($number_Y_only_sites / $number_XY_sites < 0.5){
                          push(@fasta_names_XY,$scaffold_name);
                          print "XY_SNP_scaff ",$scaffold_name;      
                        }
                        elsif ($number_Y_only_sites / $number_XY_sites >= 0.5){
                                push(@fasta_names_Y,$scaffold_name);      
                        }
        }
        elsif (($number_geno_tot > $minimum_total_called_sites) && 
                ($number_polym_mom > $minimum_total_polymorphic_sites) &&
                ($number_ZW_sites > $minimum_total_number_SS_calls) &&
                ($number_ZW_sites > $number_XY_sites) &&
                ($number_ZW_sites / $number_polym_mom > $ratio_geno_poly_limit)){
                        if ($number_W_only_sites / $number_ZW_sites < 0.5){
                          push(@fasta_names_ZW,$scaffold_name);      
                        }
                        elsif ($number_W_only_sites / $number_ZW_sites >= 0.5){
                                push(@fasta_names_W,$scaffold_name);      
                        }
        }    
}

@fasta_names_XY = uniq (@fasta_names_XY);
@fasta_names_ZW = uniq (@fasta_names_ZW);
@fasta_names_Y = uniq (@fasta_names_Y);
@fasta_names_W = uniq (@fasta_names_W);


print "Done with checking the scaffolds","\n";

print "Start printing the scaffolds","\n";

my $complete_sequence=();
#my $index=0;
my $line1;
my @temp1;
my $SD_system;
my $sequence_name;
my $switch=0;

while (my $line1=<DATAINPUT1>) {
        chomp($line1);
        @temp1=split(/[>\s]/,$line1);

        if($switch==1) {
                if ($line1!~/^>/){
                #print "temp4 ",$temp4[0];
                #print "line 4 ",$line4;
                $complete_sequence=$complete_sequence.$temp1[0];
                }
                else {
                $switch=0;
                print "CS ", $complete_sequence,"\n";
                print OUTFILE $sequence_name,"\t",$SD_system,"\n",$complete_sequence,"\n";
                $complete_sequence=();
                }

        }

        if(defined($temp1[1])){
                print $temp1[1],"\n";
                #print scalar @fasta_names,"\n";
                        if(grep $_ eq $temp1[1], @fasta_names_XY) {
                                $sequence_name=$line1;
                                $SD_system="XY";
                                #print OUTFILE3 $line4,"\n"; #print the sequence name
                                print "seq name ",$sequence_name;
                                #print "switch 0",$line4,"\n";
                                $switch=1;
                                my $index=0;
                                $index++ until $fasta_names_XY[$index] eq "$temp1[1]";
                                splice(@fasta_names_XY, $index, 1);
                        #print "index ",$index;
                        }
                        elsif(grep $_ eq $temp1[1], @fasta_names_ZW){
                                $sequence_name=$line1;
                                $SD_system="ZW";
                                $switch=1;
                                my $index=0;
                                $index++ until $fasta_names_ZW[$index] eq "$temp1[1]";
                                splice(@fasta_names_ZW, $index, 1);
                        }
                        elsif(grep $_ eq $temp1[1], @fasta_names_W){
                                $sequence_name=$line1;
                                $SD_system="ZW_Wscaffold";
                                $switch=1;
                                my $index=0;
                                $index++ until $fasta_names_W[$index] eq "$temp1[1]";
                                splice(@fasta_names_W, $index, 1);
                        }
                        elsif(grep $_ eq $temp1[1], @fasta_names_Y){
                                $sequence_name=$line1;
                                $SD_system="XY_Yscaffold";
                                $switch=1;
                                my $index=0;
                                $index++ until $fasta_names_Y[$index] eq "$temp1[1]";
                                splice(@fasta_names_Y, $index, 1);
                        }
        }
}

close DATAINPUT;
print "Done with input file \n";
close DATAINPUT1;
print "Done with input file 1\n";
close OUTFILE;
print "Done with outputfile \n";

```
**Criteria used**:

- As specified in the 3rd part script: `Hymenochirus_putative_sex_linked_opt.fa` (no effect if we only change the ratio $ratio_geno_poly_limit to 0.5)

          > 176 scaffolds

- $ratio_geno_poly_limit = 0.8 & $minimum_total_called_sites = 50: `Hymenochirus_putative_sex_linked_opt_ratio08mingen50.fa`

          > 173 scaffolds identified as "XY_Yscaffold"

###Blast of SL scaffolds
Blast of `Hymenochirus_putative_sex_linked_opt.fa` on `xenTro9_genome_HARDmasked_blastable`, `BJE3814_genomeAbyss_blastable` (`-evalue 1e-60`), `BJE3814_genomeAbyss_blastable` (`-evalue 1e-60`)
```
blastn -evalue 1e-20 -query /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Unified_genotyper/Hymenochirus_putative_sex_linked_opt.fa -db /work/ben/2016_Hymenochirus/xenTro9/xenTro9_genome_HARDmasked_blastable -out /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Unified_genotyper/Hymenochirus_chimerical_putative_sex_linked_Phred20_UnifiedGenotyper_NonString_xenTro9_hard_mask_e20 -outfmt 6 -max_target_seqs 1

blastn -evalue 1e-60 -query /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Unified_genotyper/Hymenochirus_putative_sex_linked_opt.fa -db /work/ben/2016_Hymenochirus/BJE3814/BJE3814_genomeAbyss_blastable -out /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Unified_genotyper/Hymenochirus_chimerical_putative_sex_linked_Phred20_UnifiedGenotyper_NonString_BJE3814abyss_e60 -outfmt 6 -max_target_seqs 1
```
We used the same criteria after masking the repeats (RepeatMasker `version open-3.2.6`, `-species "xenopus genus"`). Input becomes `Hymenochirus_putative_sex_linked_opt.fa.masked` and in the output name `*_NonString_masked_*`. When we blasted against *X.tropicalis*, we still have the same issue with the scaffold `C77398520` that blasted on Chr01 a lot of times with a length of 128 (all the times, same part of the scaffold that blasted at various places on the Chr01). Decided to mask the repeats using the 2 libraries (mom and dad) previously made using repARK/TEclass:
```
/usr/local/RepeatMasker/RepeatMasker -dir /net/infofile4-inside/volume1/scratch/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/UnifiedGenotyper/noMarkDupli/multiple_steps -lib /home/evanslab/Hymeno_fastqc/repeatmasker_analysis/SOAP_chimerical_genome/repeat_library_Female_Male_Merged_libRepARKTEclass.fasta -pa 4 -a /4/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/UnifiedGenotyper/noMarkDupli/multiple_steps/REPARK_masked/Hymenochirus_putative_sex_linked_opt.f
```
Issue solved. Considering only the match > 100 bp, the scaffolds only match against Chr04 (`Hymenochirus_chimerical_putative_sex_linked_Phred20_UnifiedGenotyper_linked_opt_RepARKmasked_xenTro9_hard_mask_e5`).

We then blast the results of more stringent criteria from `3rd_part.pl`: `Hymenochirus_putative_sex_linked_opt_ratio08mingen50`(e-value Abyss assemblies: `1e-70`, *X. tropicalis* `1e-20`, `1e-5`) as before repeatMaker using xenopus library and home made libraries. Again the results map only against Chr04. We then decided to map on *X. laevis* genome ([xenbase - version 9.1](http://gbrowse.xenbase.org/fgb2/gbrowse/xl9_1/?)). `scaffold348337` map to a length of `956` on `chr4L`. So I mapped against the Abyss genomes (`e70`) and xenbase *X. laevis* genome online to see if a gene appeared: grm2 (interesting publication about Metabotropic Glutamate Receptor Ligands [here](http://www.sciencedirect.com/science/article/pii/S002839081200442X)). Differences between male and female within this gene sequence but in a region of multiple C...    

When we check with the sequence assembly if the sites identified with GBS data as "only one sex" are really absent in the mother: it is mostly not the case (example: `scaffold310710`,`scaffold348337` of the chimerical assembly, when blasted against the abyss scaffolds of the mother and the father: no only one sex sites.). When we are looking at the restriction sites on the scaffolds of abyss assemblies: variation between mother and father and some in the middle of 2 sets repeat sequences. Variation in coverage between sites seems to mainly due to sequencing not because of real differences between males and females. 

When we visualize (IGV) the reads (from GBS data) mapping to the scaffolds with identified "only one sex" sites (ex.:`scaffold89772`), regions with reads for males but 0 for all the females even if this region was identified as present in the assembly made using HiSeq data idependently for each parent. Heterozigosity of restriction enzyme sites, repeat sequences can create issues for genotype identification (see for example [Davey et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3712469/) and [Beissinger et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3606087/))

Need to focus on parts for which we have data for males and females. See if same scaffolds identified with a sex-inheritance pattern.
```
blastn -evalue 1e-5 -query /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Haplotype_caller/Hymenochirus_putative_sex_linked_opt_tot1SS1polym1ratio0_repARKmasked.fa.masked -db /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Unified_genotyper/Xla_v91_genome_HARDmasked_blastable -out /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Haplotype_caller/Hymenochirus_chimerical_putative_sex_linked_Phred20_Haplotype_caller_linked_opt_tot1SS1polym1ratio0_RepARKmasked_Xla91_hard_mask_e5 -outfmt 6 -max_target_seqs 1

blastn -evalue 1e-5 -query /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Haplotype_caller/Hymenochirus_putative_sex_linked_opt_tot1SS1polym1ratio0_repARKmasked.fa.masked -db /work/ben/2016_Hymenochirus/xenTro9/xenTro9_genome_HARDmasked_blastable -out /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Haplotype_caller/Hymenochirus_chimerical_putative_sex_linked_Phred20_Haplotype_caller_linked_opt_tot1SS1polym1ratio0_RepARKmasked_xenTro9_hard_mask_e5 -outfmt 6 -max_target_seqs 1
```
`scaffold89772` displays sites identified as only present in one sex and also SNPs with sex-inheritance pattern. When we blast to both parents Abyss assembly: regions present in both sex. But the scaffold has a lot of repeats identified and masked when we used our repARK libraries.

**Important point:** When we blast either scaffolds with sites identified as "only one sex" or with SNPs displaying a sex-inheritance pattern, after repeat masking with libraries from repARK: the scaffolds mapping to *X. tropicalis* map to Chr.04 (same with *X. laevis*).

If want to print the query and subject sequences:
```
blastn -evalue 1e-70 -query /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Unified_genotyper/scaffold348337.fa -db /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Unified_genotyper/Xla_v91_genome_HARDmasked_blastable -out /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Unified_genotyper/scaffold348337_Xlaevis91_e5_qseq_sseq -outfmt "6 qseq sseq" -max_target_seqs 1
```
###Potential sex-linked genes on *X. tropicalis* Chr.04
**- SOX6**: blast chimerical scaffold `C91947791`. Scaffold to small to be included in the supercontigs (\<500bp). Blast against male Abyss assembly: scaffold 24548123 (= supercontig 2: 160180161-160181357). Using data when we mapped HiSeq reads against assembly: a few SNPs (but no data from offspring to know if sex-inhheritance pattern).

**- DMRT5**: if directly blast the gene seq. -> no hit. Needed to use sequence from the DM domain only. The scaffolds obtained don't have GBS data. Need to blast each scaffold again against *X. tropicalis* to see if now we can separate the different members of DM family and particularly the scaffold containing DMRT5.
```
tblastx -evalue 1e-1 -query /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Haplotype_caller/DM_domain.fa -db /work/ben/2016_Hymenochirus/BJE3814/BJE3814_genomeAbyss_blastable -out /work/ben/2016_Hymenochirus/putative_sex_linked_regions_blast_Haplotype_caller/BJE3814_abyss_DM_domain_tblastx_e1_target_seq_3_qseq_sseq -outfmt "6 qseq sseq" -max_target_seqs 1

awk -v seq="C92128961" -v RS='>' '$1 == seq {print RS $0}' /work/ben/2016_Hymenochirus/SOAP_genomes/SOAP_Hymeno_genome.scafSeq >SOAP_chimerical_scaffoldC92128961.fa 
```
|SOAP_chimerical_scaffold|DM-member|Abyss_BJE3814_mom_scaffold|Abyss_BJE3815_dad_scaffold|
-------------------------|----------|----------|----------|
|C92128961|DMRT1 (Chr.01)|||
|**C92682523**|**DMRTa2 (Chr.04)**|25142173|24873906|
|scaffold289841|DMRT1a1 (Chr.01)|||
|scaffold122580|DMRT2 (Chr.01)|||
|C92174591|DMRT3 (Chr.01)|||
|scaffold264|not clear|||
Delimitation of real scaffolds within super_contig 
```
evanslab:multiple_steps % grep "25142173" /net/infofile2/2/scratch/evanslab_backups/Hymenochirus_2016/abyss/BJE3814-8_abyss_supercontigs_index
5	25142173	182762321	182781571
evanslab:multiple_steps % grep "24873906" /net/infofile2/2/scratch/evanslab_backups/Hymenochirus_2016/abyss/BJE3815-8_abyss_supercontigs_index
6	24873906	22045521	22062501

vcftools --vcf ~/Hymeno_fastqc/GATK/BJE3815_nonrecal_varonly.vcf --chr "supercontig_6" --from-bp 22045521 --to-bp 22062501 --recode --recode-INFO-all --out /4/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/GVCF/multiple_steps/BJE3815_nonrecal_varonly_scaffold24873906
/usr/local/vcftools/src/perl/vcf-to-tab < /4/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/GVCF/multiple_steps/BJE3815_nonrecal_varonly_scaffold24873906.recode.vcf > /4/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/GVCF/multiple_steps/BJE3815_nonrecal_varonly_scaffold24873906.recode.tab
more /4/evanslab/Hymenochirus_2016/GBS_data/process_radtags_demultiplex/bwa_results/Phred20/all/GVCF/multiple_steps/BJE3815_nonrecal_varonly_scaffold24873906.recode.tab
#CHROM	POS	REF	/home/evanslab/Hymeno_fastqc/map_reads_to_abyss_genomes/super_contigs/BJE381
5_genomeAbyss_supercontigs_reads14sorted	/home/evanslab/Hymeno_fastqc/map_reads_to_abyss_geno
mes/super_contigs/BJE3815_genomeAbyss_supercontigs_reads15sorted
supercontig_6	22045747	C	C/C	C/A
[...] 61 sites
```
When we look at the SNP obtained using HiSeq data from the mother and the father regarding father Abyss scaffold 24873906 (=chimerical C92682523): everytime pattern homozygous mother/heterozygous father.

Check if the same using mother Abyss genome as the reference: 67 SNP, with same heterozygosity pattern!!!

***Potential roles of DMRTa2***: "*DmrtA2 may play a role in ovary-differentiation and mature-ovary maintenance.* [in ayu]" ([Wang et al. 2014](http://molehr.oxfordjournals.org/content/20/10/960.full)), "*This study reveals, for the first time, the requirement of DMRTA2 for normal human female embryonic germ cell development. DMRTA2 appears to be necessary for proper differentiation of oogonia, prior to entry into meiosis, in the human species.*" ([Poulain et al. 2014](http://molehr.oxfordjournals.org/content/20/10/960.full)), "*zebrafish Dmrt5 have potentially important roles in gonadal development*" ([Guo et al. 2004](https://www.ncbi.nlm.nih.gov/pubmed/15474464)).

**- Kank4**

###Potential sex-linked scaffolds and *X. tropicalis* (blast on Ensembl)
|SOAP_chimerical_scaffold|Inheritance pattern|Overlapped genes|Chr.|Function|SNP location on scaffold|Abyss genomes M/D\*|
-------------------------|----------|----------|----------|----------|----------|----------|
scaffold114984 | XY_Yscaffold | ENSXETG00000032333 - probably gpc family||Glypican prod.|1159|C/A|
scaffold147062 | XY | ptprf |04|signaling molecule |5250|
scaffold97784  | XY | sall1 |04|zinc finger transcription factor |1133|
scaffold95694 | XY_Yscaffold | cacna1i |04|T-type voltage-gated Ca2+|9488|
scaffold34529 | XY | ppp6r3 |04|SAP family cell cycle dependent phosphatase-associated protein |184|
scaffold40934 | XY | hmcn1 |04|skin stability|8102|
scaffold73911 | XY|	ENSXETG00000030866 - probably ppp1r family|||1290|
scaffold75704 | ZW| atrx |01|transcriptional regulator|15301|
scaffold236714 | XY_Yscaffold | vac14 |04|Uncharacterized conserved protein |96|
scaffold353076 | XY_Yscaffold | rassf1 |04|Ras GTPase effector|1139|
scaffold428256 | XY | ifitm1 | 4L 4L laevis|interferon induced transmembrane protein 1|2439|
scaffold434939 | XY_Yscaffold | FADS1 | 4L 4L laevis|Delta 6-fatty acid desaturase/delta-8 sphingolipid desaturase|8027|
C92080241 | XY | vps9d1 | scaffolds only |Vacuolar assembly/sorting protein VPS9|571|

\*: particularly for `Yscaffold` meaning sites only present in males. See if you see that in the genome data. Also look if variation at a restriction sites (if yes cool) and read coverage.

Want to select genotypes from a particular region 
```
vcftools --gzvcf BJE3814_nonrecal_varonly.vcf.gz --chr "supercontig_1" --from-bp --to-bp --recode  --recode-INFO-all | gzip -c > BJE3814_nonrecal_varonly_supercontig_1.vcf.gz
```
